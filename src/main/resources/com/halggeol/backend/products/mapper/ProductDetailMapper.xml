<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.halggeol.backend.products.mapper.ProductDetailMapper">

<!--  예금  -->
  <resultMap id="depositDetailResponseDTOMap" type="com.halggeol.backend.products.dto.DepositDetailResponseDTO">
    <id property="id" column="d_id"/>
    <result property="name" column="d_name"/>
    <result property="rate" column="d_rate"/>
    <result property="primeRate" column="d_prime_rate"/>
    <result property="joinWay" column="d_join_way"/>
    <result property="endDate" column="d_end_date"/>
    <result property="maxLimit" column="d_max_limit"/>
    <result property="joinMember" column="d_join_member"/>
    <result property="joinDeny" column="d_join_deny"/>
    <result property="bonusCondition" column="d_bonus_condition"/>
    <result property="rateType" column="d_rate_type"/>
    <result property="minLimit" column="d_min_limit"/>
    <result property="company" column="d_company"/>
    <result property="score" column="d_score"/>
    <result property="risk" column="d_risk"/>
    <result property="regLink" column="d_reg_link"/>
    <result property="caution" column="d_caution"/>
    <result property="viewCnt" column="d_view_cnt"/>
    <result property="scrapCnt" column="d_scrap_cnt"/>
    <result property="regretCnt" column="d_regret_cnt"/>

    <result property="minSaveTerm" column="d_min_save_term"/>
    <result property="maxSaveTerm" column="d_max_save_term"/>

    <result property="description" column="d_description"/>

    <result property="advantage" column="pd_advantage"/>
    <result property="disadvantage" column="pd_disadvantage"/>
    <result property="isScraped" column="is_scraped"/>
  </resultMap>

  <select id="selectBaseDepositDetailById" resultMap="depositDetailResponseDTOMap">
    SELECT
      d.id AS d_id,
      d.name AS d_name,
      d.rate AS d_rate,
      d.prime_rate AS d_prime_rate,
      d.join_way AS d_join_way,
      d.end_date AS d_end_date,
      d.max_limit AS d_max_limit,
      d.join_member AS d_join_member,
      d.join_deny AS d_join_deny,
      d.bonus_condition AS d_bonus_condition,
      d.rate_type AS d_rate_type,
      d.min_limit AS d_min_limit,
      d.company AS d_company,
      d.score AS d_score,
      d.risk AS d_risk,
      d.reg_link AS d_reg_link,
      d.caution AS d_caution,
      d.view_cnt AS d_view_cnt,
      d.scrap_cnt AS d_scrap_cnt,
      d.regret_cnt AS d_regret_cnt,
      d.min_save_term AS d_min_save_term,
      d.max_save_term AS d_max_save_term,
      d.description AS d_description,
      NULL AS pd_advantage,
      NULL AS pd_disadvantage,
      false AS is_scraped
    FROM
      deposit d
    WHERE
      d.id = #{depositId}
  </select>

  <select id="selectUserSpecificDataForDeposit" resultType="com.halggeol.backend.products.dto.UserSpecificDataResponseDTO">
    SELECT
      pd.advantage AS advantage,
      pd.disadvantage AS disadvantage,
      CASE WHEN s.user_id IS NOT NULL THEN true ELSE false END AS isScraped
    FROM
      users u
        LEFT JOIN
      personalized_description pd ON u.algo_code = pd.algo_code AND pd.product_id = #{productId}
        LEFT JOIN
      scrap s ON u.id = s.user_id AND s.product_id = #{productId}
    WHERE
      u.id = #{userId}
  </select>

  <!-- 적금 -->
  <resultMap id="savingsDetailResponseDTOMap" type="com.halggeol.backend.products.dto.SavingsDetailResponseDTO">
    <id property="id" column="s_id"/>
    <result property="name" column="s_name"/>
    <result property="rate" column="s_rate"/>
    <result property="primeRate" column="s_prime_rate"/>
    <result property="joinWay" column="s_join_way"/>
    <result property="endDate" column="s_end_date"/>
    <result property="minLimit" column="s_min_limit"/>
    <result property="maxLimit" column="s_max_limit"/>
    <result property="joinMember" column="s_join_member"/>
    <result property="joinDeny" column="s_join_deny"/>
    <result property="bonusCondition" column="s_bonus_condition"/>
    <result property="rateType" column="s_rate_type"/>
    <result property="saveType" column="s_save_type"/>
    <result property="company" column="s_company"/>
    <result property="score" column="s_score"/>
    <result property="risk" column="s_risk"/>
    <result property="regLink" column="s_reg_link"/>
    <result property="caution" column="s_caution"/>
    <result property="viewCnt" column="s_view_cnt"/>
    <result property="scrapCnt" column="s_scrap_cnt"/>
    <result property="regretCnt" column="s_regret_cnt"/>

    <result property="minSaveTerm" column="s_min_save_term"/>
    <result property="maxSaveTerm" column="s_max_save_term"/>

    <result property="description" column="s_description"/>

    <result property="advantage" column="pd_advantage"/>
    <result property="disadvantage" column="pd_disadvantage"/>
    <result property="isScraped" column="is_scraped"/>
  </resultMap>
  <select id="selectBaseSavingsDetailById" resultMap="savingsDetailResponseDTOMap">
    SELECT
      s.id AS s_id,
      s.name AS s_name,
      s.rate AS s_rate,
      s.prime_rate AS s_prime_rate,
      s.join_way AS s_join_way,
      s.end_date AS s_end_date,
      s.min_limit AS s_min_limit,
      s.max_limit AS s_max_limit,
      s.join_member AS s_join_member,
      s.join_deny AS s_join_deny,
      s.bonus_condition AS s_bonus_condition,
      s.rate_type AS s_rate_type,
      s.save_type AS s_save_type,
      s.company AS s_company,
      s.score AS s_score,
      s.risk AS s_risk,
      s.reg_link AS s_reg_link,
      s.caution AS s_caution,
      s.view_cnt AS s_view_cnt,
      s.scrap_cnt AS s_scrap_cnt,
      s.regret_cnt AS s_regret_cnt,
      s.min_save_term AS s_min_save_term,
      s.max_save_term AS s_max_save_term,
      s.description AS s_description,
      NULL AS pd_advantage,
      NULL AS pd_disadvantage,
      false AS is_scraped
    FROM
      savings s
    WHERE
      s.id = #{savingsId}
  </select>

  <select id="selectUserSpecificDataForSavings" resultType="com.halggeol.backend.products.dto.UserSpecificDataResponseDTO">
    SELECT
      pd.advantage AS advantage,
      pd.disadvantage AS disadvantage,
      CASE WHEN sc.user_id IS NOT NULL THEN true ELSE false END AS isScraped
    FROM
      users u
        LEFT JOIN
      personalized_description pd ON u.algo_code = pd.algo_code AND pd.product_id = #{productId}
        LEFT JOIN
      scrap sc ON u.id = sc.user_id AND sc.product_id = #{productId}
    WHERE
      u.id = #{userId}
  </select>

  <!-- 펀드 -->
  <resultMap id="fundDetailResponseDTOMap" type="com.halggeol.backend.products.dto.FundDetailResponseDTO">
    <id property="id" column="f_id"/>
    <result property="name" column="f_name"/>
    <result property="rate" column="f_rate"/>
    <result property="fundPrice" column="f_fund_price"/>
    <result property="fundPriceMovement" column="f_fund_price_movement"/>
    <result property="TER" column="f_ter"/>
    <result property="category" column="f_category"/>
    <result property="theme" column="f_theme"/>
    <result property="investmentWarningGrade" column="f_investment_warning_grade"/>
    <result property="upfrontFee" column="f_upfront_fee"/>
    <result property="managementFee" column="f_management_fee"/>
    <result property="minLimit" column="f_min_limit"/>
    <result property="target" column="f_target"/>
    <result property="investmentType" column="f_investment_type"/>
    <result property="company" column="f_company"/>
    <result property="score" column="f_score"/>
    <result property="risk" column="f_risk"/>
    <result property="regLink" column="f_reg_link"/>
    <result property="caution" column="f_caution"/>
    <result property="viewCnt" column="f_view_cnt"/>
    <result property="scrapCnt" column="f_scrap_cnt"/>
    <result property="regretCnt" column="f_regret_cnt"/>

    <result property="description" column="f_description"/>

    <result property="advantage" column="pd_advantage"/>
    <result property="disadvantage" column="pd_disadvantage"/>
    <result property="isScraped" column="is_scraped"/>
  </resultMap>

  <select id="selectBaseFundDetailById" resultMap="fundDetailResponseDTOMap">
    SELECT
      f.id AS f_id,
      f.name AS f_name,
      f.rate AS f_rate,
      f.fund_price AS f_fund_price,
      f.fund_price_movement AS f_fund_price_movement,
      f.ter AS f_ter,
      f.category AS f_category,
      f.theme AS f_theme,
      f.investment_warning_grade AS f_investment_warning_grade,
      f.upfront_fee AS f_upfront_fee,
      f.management_fee AS f_management_fee,
      f.min_limit AS f_min_limit,
      f.target AS f_target,
      f.investment_type AS f_investment_type,
      f.company AS f_company,
      f.score AS f_score,
      f.risk AS f_risk,
      f.reg_link AS f_reg_link,
      f.caution AS f_caution,
      f.view_cnt AS f_view_cnt,
      f.scrap_cnt AS f_scrap_cnt,
      f.regret_cnt AS f_regret_cnt,
      f.description AS f_description,
      NULL AS pd_advantage,
      NULL AS pd_disadvantage,
      false AS is_scraped
    FROM
      fund f
    WHERE
      f.id = #{fundId}
  </select>

  <select id="selectUserSpecificDataForFund" resultType="com.halggeol.backend.products.dto.UserSpecificDataResponseDTO">
    SELECT
      pd.advantage AS advantage,
      pd.disadvantage AS disadvantage,
      CASE WHEN sc.user_id IS NOT NULL THEN true ELSE false END AS isScraped
    FROM
      users u
        LEFT JOIN
      personalized_description pd ON u.algo_code = pd.algo_code AND pd.product_id = #{productId}
        LEFT JOIN
      scrap sc ON u.id = sc.user_id AND sc.product_id = #{productId}
    WHERE
      u.id = #{userId}
  </select>

  <!-- 외화 -->
  <resultMap id="forexDetailResponseDTOMap" type="com.halggeol.backend.products.dto.ForexDetailResponseDTO">
    <id property="id" column="fx_id"/>
    <result property="name" column="fx_name"/>
    <result property="rate" column="fx_rate"/>
    <result property="description" column="fx_description"/>
    <result property="currency" column="fx_currency"/>

    <result property="minLimit" column="fx_min_limit"/>
    <result property="maxLimit" column="fx_max_limit"/>

    <result property="regLimitDate" column="fx_reg_limit_date"/>
    <result property="autoRenew" column="fx_auto_renew"/>
    <result property="extraDeposit" column="fx_extra_deposit"/>
    <result property="rateGiveWay" column="fx_rate_give_way"/>
    <result property="taxRefund" column="fx_tax_refund"/>
    <result property="protect" column="fx_protect"/>
    <result property="company" column="fx_company"/>
    <result property="score" column="fx_score"/>
    <result property="risk" column="fx_risk"/>
    <result property="regLink" column="fx_reg_link"/>
    <result property="caution" column="fx_caution"/>
    <result property="viewCnt" column="fx_view_cnt"/>
    <result property="scrapCnt" column="fx_scrap_cnt"/>
    <result property="regretCnt" column="fx_regret_cnt"/>

    <result property="rateType" column="fx_rate_type"/>
    <result property="minSaveTerm" column="fx_min_save_term"/>
    <result property="maxSaveTerm" column="fx_max_save_term"/>

    <result property="advantage" column="pd_advantage"/>
    <result property="disadvantage" column="pd_disadvantage"/>
    <result property="isScraped" column="is_scraped"/>
  </resultMap>
  <select id="selectBaseForexDetailById" resultMap="forexDetailResponseDTOMap">
    SELECT
      fx.id AS fx_id,
      fx.name AS fx_name,
      fx.rate AS fx_rate,
      fx.currency AS fx_currency,
      fx.min_limit AS fx_min_limit,
      fx.max_limit AS fx_max_limit,
      fx.reg_limit_date AS fx_reg_limit_date,
      fx.auto_renew AS fx_auto_renew,
      fx.extra_deposit AS fx_extra_deposit,
      fx.rate_give_way AS fx_rate_give_way,
      fx.tax_refund AS fx_tax_refund,
      fx.protect AS fx_protect,
      fx.company AS fx_company,
      fx.score AS fx_score,
      fx.risk AS fx_risk,
      fx.reg_link AS fx_reg_link,
      fx.caution AS fx_caution,
      fx.view_cnt AS fx_view_cnt,
      fx.scrap_cnt AS fx_scrap_cnt,
      fx.regret_cnt AS fx_regret_cnt,
      fx.description AS fx_description,
      fx.rate_type AS fx_rate_type,
      fx.min_save_term AS fx_min_save_term,
      fx.max_save_term AS fx_max_save_term,
      NULL AS pd_advantage,
      NULL AS pd_disadvantage,
      false AS is_scraped
    FROM
      forex fx
    WHERE
      fx.id = #{forexId}
  </select>

  <select id="selectUserSpecificDataForForex" resultType="com.halggeol.backend.products.dto.UserSpecificDataResponseDTO">
    SELECT
      pd.advantage AS advantage,
      pd.disadvantage AS disadvantage,
      CASE WHEN sc.user_id IS NOT NULL THEN true ELSE false END AS isScraped
    FROM
      users u
        LEFT JOIN
      personalized_description pd ON u.algo_code = pd.algo_code AND pd.product_id = #{productId}
        LEFT JOIN
      scrap sc ON u.id = sc.user_id AND sc.product_id = #{productId}
    WHERE
      u.id = #{userId}
  </select>

  <!-- 연금 -->
  <resultMap id="pensionDetailResponseDTOMap" type="com.halggeol.backend.products.dto.PensionDetailResponseDTO">
    <id property="id" column="p_id"/>
    <result property="name" column="p_name"/>
    <result property="rate" column="p_rate"/>
    <result property="pensionPriceMovement" column="p_pension_price_movement"/>
    <result property="pensionKind" column="p_pension_kind"/>
    <result property="pensionType" column="p_pension_type"/>
    <result property="minGuaranteeRate" column="p_min_guarantee_rate"/>
    <result property="endDate" column="p_end_date"/>
    <result property="company" column="p_company"/>
    <result property="score" column="p_score"/>
    <result property="risk" column="p_risk"/>
    <result property="regLink" column="p_reg_link"/>
    <result property="caution" column="p_caution"/>
    <result property="viewCnt" column="p_view_cnt"/>
    <result property="scrapCnt" column="p_scrap_cnt"/>
    <result property="regretCnt" column="p_regret_cnt"/>

    <result property="saveTerm" column="p_save_term"/>
    <result property="rateType" column="p_rate_type"/>
    <result property="minLimit" column="p_min_limit"/>
    <result property="maxLimit" column="p_max_limit"/>

    <result property="description" column="p_description"/>

    <result property="advantage" column="pd_advantage"/>
    <result property="disadvantage" column="pd_disadvantage"/>
    <result property="isScraped" column="is_scraped"/>
  </resultMap>

  <select id="selectBasePensionDetailById" resultMap="pensionDetailResponseDTOMap">
    SELECT
      pn.id AS p_id,
      pn.name AS p_name,
      pn.rate AS p_rate,
      pn.pension_price_movement AS p_pension_price_movement,
      pn.pension_kind AS p_pension_kind,
      pn.pension_type AS p_pension_type,
      pn.min_guarantee_rate AS p_min_guarantee_rate,
      pn.end_date AS p_end_date,
      pn.company AS p_company,
      pn.score AS p_score,
      pn.risk AS p_risk,
      pn.reg_link AS p_reg_link,
      pn.caution AS p_caution,
      pn.view_cnt AS p_view_cnt,
      pn.scrap_cnt AS p_scrap_cnt,
      pn.regret_cnt AS p_regret_cnt,
      pn.save_term AS p_save_term,
      pn.rate_type AS p_rate_type,
      pn.min_limit AS p_min_limit,
      pn.max_limit AS p_max_limit,
      pn.description AS p_description,
      NULL AS pd_advantage,
      NULL AS pd_disadvantage,
      false AS is_scraped
    FROM
      pension pn
    WHERE
      pn.id = #{pensionId}
  </select>

  <select id="selectUserSpecificDataForPension" resultType="com.halggeol.backend.products.dto.UserSpecificDataResponseDTO">
    SELECT
      pd.advantage AS advantage,
      pd.disadvantage AS disadvantage,
      CASE WHEN sc.user_id IS NOT NULL THEN true ELSE false END AS isScraped
    FROM
      users u
        LEFT JOIN
      personalized_description pd ON u.algo_code = pd.algo_code AND pd.product_id = #{productId}
        LEFT JOIN
      scrap sc ON u.id = sc.user_id AND sc.product_id = #{productId}
    WHERE
      u.id = #{userId}
  </select>

  <update id="incrementDepositViewCount">
    UPDATE deposit SET view_cnt = view_cnt + 1 WHERE id = #{productId}
  </update>
  <update id="incrementSavingsViewCount">
    UPDATE savings SET view_cnt = view_cnt + 1 WHERE id = #{productId}
  </update>
  <update id="incrementFundViewCount">
    UPDATE fund SET view_cnt = view_cnt + 1 WHERE id = #{productId}
  </update>
  <update id="incrementForexViewCount">
    UPDATE forex SET view_cnt = view_cnt + 1 WHERE id = #{productId}
  </update>
  <update id="incrementPensionViewCount">
    UPDATE pension SET view_cnt = view_cnt + 1 WHERE id = #{productId}
  </update>

  <update id="updateProductStatus">
    UPDATE rec_item
    SET
      product1_status = CASE
                          WHEN product1_id = #{productId} THEN #{productStatus}
                          ELSE product1_status
        END,
      product2_status = CASE
                          WHEN product2_id = #{productId} THEN #{productStatus}
                          ELSE product2_status
        END,
      product3_status = CASE
                          WHEN product3_id = #{productId} THEN #{productStatus}
                          ELSE product3_status
        END,
      product4_status = CASE
                          WHEN product4_id = #{productId} THEN #{productStatus}
                          ELSE product4_status
        END,
      product5_status = CASE
                          WHEN product5_id = #{productId} THEN #{productStatus}
                          ELSE product5_status
        END
    WHERE
      user_id = #{userId}
      AND rec_id = (
      SELECT sub.rec_id
      FROM (
             SELECT rec_id
             FROM rec_item
             WHERE user_id = #{userId}
               AND (
               product1_id = #{productId} OR
               product2_id = #{productId} OR
               product3_id = #{productId} OR
               product4_id = #{productId} OR
               product5_id = #{productId}
               )
             ORDER BY rec_date DESC, rec_id DESC -- rec_date가 같을 경우 rec_id로 최종 최신 레코드 식별
               LIMIT 1
           ) AS sub
    )
      AND (
      product1_id = #{productId} OR
      product2_id = #{productId} OR
      product3_id = #{productId} OR
      product4_id = #{productId} OR
      product5_id = #{productId}
      );
  </update>

  <select id="selectProductStatus" resultType="java.lang.String">
    SELECT
      CASE #{productId}
        WHEN T.product1_id THEN T.product1_status
        WHEN T.product2_id THEN T.product2_status
        WHEN T.product3_id THEN T.product3_status
        WHEN T.product4_id THEN T.product4_status
        WHEN T.product5_id THEN T.product5_status
        ELSE NULL
        END AS product_status
    FROM
      rec_item T
    WHERE
      T.user_id = #{userId}
      AND (
      T.product1_id = #{productId} OR
      T.product2_id = #{productId} OR
      T.product3_id = #{productId} OR
      T.product4_id = #{productId} OR
      T.product5_id = #{productId}
      )
    ORDER BY
      T.rec_date DESC, T.rec_id DESC
    LIMIT 1;
</select>
</mapper>