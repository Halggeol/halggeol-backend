<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.halggeol.backend.products.unified.mapper.UnifiedProductMapper">

<!--  금융 상품 검색 및 필터링-->
  <select id="selectFilteredProducts" resultType="com.halggeol.backend.products.unified.dto.UnifiedProductResponseDTO">
    SELECT
    d.id AS productId,
    d.name,
    d.company,
    'deposit' AS type,
    d.min_save_term AS tag1,
    d.max_save_term AS tag2,
    NULL AS tag3,
    d.prime_rate AS title,
    CAST(d.rate AS CHAR) AS subTitle,
    d.f_sector AS fSector,
    NULL AS saveTerm,
    d.min_save_term,
    d.max_save_term,
    d.min_limit AS minAmount,
    d.view_cnt,
    d.scrap_cnt
    FROM deposit d

    UNION ALL

    SELECT
    s.id AS productId,
    s.name,
    s.company,
    'savings' AS type,
    s.min_save_term AS tag1,
    s.max_save_term AS tag2,
    NULL AS tag3,
    s.prime_rate AS title,
    CAST(s.rate AS CHAR) AS subTitle,
    s.f_sector AS fSector,
    NULL AS saveTerm,
    s.min_save_term,
    s.max_save_term,
    s.min_limit AS minAmount,
    s.view_cnt,
    s.scrap_cnt
    FROM savings s

    UNION ALL

    SELECT
    p.id AS productId,
    p.name,
    p.company,
    'pension' AS type,
    p.pension_type AS tag1,
    p.pension_kind AS tag2,
    p.risk AS tag3,
    -- 조건 분기된 title
    CASE
    WHEN p.pension_type = 1 THEN p.rate
    ELSE p.pension_price_movement
    END AS title,
    -- 조건 분기된 subTitle
    CAST(
    CASE
    WHEN p.pension_type = 1 THEN p.min_guarantee_rate
    ELSE NULL
    END AS CHAR
    ) AS subTitle,
    p.f_sector AS fSector,
    p.save_term AS saveTerm,
    NULL AS min_save_term,
    NULL AS max_save_term,
    p.min_limit AS minAmount,
    p.view_cnt,
    p.scrap_cnt
    FROM pension p

    UNION ALL

    SELECT
    f.id AS productId,
    f.name,
    f.company,
    'fund' AS type,
    f.category AS tag1,
    f.theme AS tag2,
    f.investment_warning_grade AS tag3,
    f.rate AS title,
    NULL AS subTitle,
    f.f_sector AS fSector,
    NULL AS saveTerm,
    NULL AS min_save_term,
    NULL AS max_save_term,
    f.min_limit AS minAmount,
    f.view_cnt,
    f.scrap_cnt
    FROM fund f

    UNION ALL

    SELECT
    fx.id AS productId,
    fx.name,
    fx.company,
    'forex' AS type,
    fx.currency AS tag1,
    NULL AS tag2,
    NULL AS tag3,
    fx.rate AS title,
    CAST(fx.rate_give_way AS CHAR) AS subTitle,
    fx.f_sector AS fSector,
    NULL AS saveTerm,
    fx.min_save_term,
    fx.max_save_term,
    fx.min_limit AS minAmount,
    fx.view_cnt,
    fx.scrap_cnt
    FROM forex fx
    ) AS unified
    WHERE 1=1
    <if test="keyword != null and keyword != ''">
      AND name LIKE CONCAT('%', #{keyword}, '%')
    </if>
    <if test="type != null and type != ''">
      AND type = #{type}
    </if>
    <if test="fSector != null">
      AND fSector = #{fSector}
    </if>
    <if test="saveTerm != null">
      AND saveTerm = #{saveTerm}
    </if>
    <if test="minAmount != null and minAmount != ''">
      AND (CASE WHEN minAmount REGEXP '^[0-9]+$' THEN CAST(minAmount AS UNSIGNED) ELSE NULL END) >= #{minAmount}
    </if>

    <choose>
      <when test="sort == 'rateDesc'">
        ORDER BY CAST(title AS DECIMAL(10, 5)) DESC
      </when>
      <when test="sort == 'popularDesc'">
        ORDER BY view_cnt + (scrap_cnt * 2) DESC
      </when>
      <otherwise>
        ORDER BY (view_cnt + scrap_cnt * 2) DESC
      </otherwise>
    </choose>
  </select>

  <!--  TODO : 현재 period에 대해서 임의 값을 삽입해놨는데, 명확한 기준을 가지고 재수정 해야함 -->
  <select id="selectUnifiedProductsOrderByRegretCnt" resultType="com.halggeol.backend.products.unified.dto.UnifiedProductRegretRankingResponseDTO">
    SELECT
      ranked_products.rank_num AS `rank`,
      ranked_products.productId,
      ranked_products.name AS productName,
      ranked_products.risk,
      CASE WHEN ranked_products.rank_num = 1 THEN ranked_products.rate ELSE NULL END AS rate,
      CASE WHEN ranked_products.rank_num = 1 THEN ranked_products.period ELSE NULL END AS period
    FROM (
           SELECT
             *,
             ROW_NUMBER() OVER (ORDER BY regret_cnt DESC) AS rank_num -- regret_cnt 기준으로 순위를 매깁니다.
           FROM (
                  -- 예금 (deposit) 테이블
                  SELECT
                    d.id AS productId,
                    d.name,
                    d.regret_cnt,
                    d.risk,
                    d.rate,
                    12 AS period -- 예금은 period를 12로 고정
                  FROM deposit d

                  UNION ALL

                  -- 적금 (savings) 테이블
                  SELECT
                    s.id AS productId,
                    s.name,
                    s.regret_cnt,
                    s.risk,
                    s.rate,
                    12 AS period -- 적금은 period를 12로 고정
                  FROM savings s

                  UNION ALL

                  -- 연금 (pension) 테이블
                  SELECT
                    p.id AS productId,
                    p.name,
                    p.regret_cnt,
                    p.risk,
                    p.rate,
                    3 AS period -- 연금은 period를 3으로 고정
                  FROM pension p

                  UNION ALL

                  -- 펀드 (fund) 테이블
                  SELECT
                    f.id AS productId,
                    f.name,
                    f.regret_cnt,
                    f.risk,
                    f.rate,
                    3 AS period -- 외화는 period를 3으로 고정
                  FROM fund f

                  UNION ALL

                  SELECT
                    fx.id AS productId,
                    fx.name,
                    fx.regret_cnt,
                    fx.risk,
                    fx.rate,
                    3 AS period -- 외화는 period를 3으로 고정
                  FROM forex fx
                ) AS combined_unranked_products
         ) AS ranked_products
    WHERE ranked_products.rank_num <![CDATA[<=]]> 5
    ORDER BY ranked_products.rank_num ASC;
  </select>

</mapper>
